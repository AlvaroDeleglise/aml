{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Linear Models for Classification"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    
    "\n",
    "## Linear Models for Classification, SVMs\n",
    "\n",
    "02/12/20\n",
    "\n",
    "Andreas C. Müller\n",
    "\n",
    "\n",
    "\n",
    "Today we're going to talk about linear models for\n",
    "classification, and in addition to that some general\n",
    "principles and advanced topics surrounding general models,\n",
    "both for classification and regression.\n",
    "\n",
    "FIXME: in regularizing SVM, long vs short normal vectors.\n",
    "FIXME do we need ovo? we kinda do, right?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    
    "\n",
    "## Linear models for \n",
    "binary\n",
    " classfication\n",
    "\n",
    "\n",
    "\n",
    "We'll first start with linear models for binary\n",
    "classification, so if there are only two classes. That makes\n",
    "the models much easier to understand."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    ".center[\n",
    "![:scale 55%](images/linear_boundary_vector.png)\n",
    "]\n",
    "\n",
    "$$\\hat{y} = \\text{sign}(w^T \\textbf{x} + b) = \\text{sign}\\left(\\sum\\limits_{i}w_ix_i + b\\right)$$\n",
    "\n",
    "\n",
    "\n",
    "Similar to the regression case, basically all linear models\n",
    "for classification have the same way to make predictions. As\n",
    "with regression, they compute an inner product of a weight\n",
    "vector w with the feature vector x, and add some bias b. The\n",
    "result of that is a real number, as in regression. For\n",
    "classification, however, we only look at the sign of the\n",
    "result, so whether it is negative or positive. If it's\n",
    "positive, we predict one class, usually called +1, if it's\n",
    "negative, we predict the other class, usually called -1. If\n",
    "the result is 0, by convention the positive class is\n",
    "predicted, but because it's a floating point number that\n",
    "doesn't really happen in practice. You'll see that sometimes\n",
    "in my notation I will not have a $b$. That's because you can\n",
    "always add a constant feature to x to achieve the same\n",
    "effect (thought you would then need to leave that feature\n",
    "out of the regularization). So when I write $w^Tx$ without a\n",
    "$b$ assume that there is a constant feature added that is\n",
    "not part of any regularization.\n",
    "\n",
    "Geometrially, what the formula means is that the decision\n",
    "boundary of a linear classifier will be a hyperplane in the\n",
    "feature space, where w is the normal vector of that plane.\n",
    "In the 2d example here, it's just a line separating red and\n",
    "blue. Everything on the right hand side would be classified\n",
    "as blue by this classifier, and everything on the left-hand\n",
    "side as red.\n",
    "\n",
    "Questions? So again, the learning here consists of finding\n",
    "parameters w and b based on the training set, and that is\n",
    "where the different algorithms differ. There are quite a lot\n",
    "of algorithms out there, and there are also quite a lot in\n",
    "scikit-learn, but we'll only discuss the most common ones.\n",
    "\n",
    "The most straight-forward way to approach finding w and b is\n",
    "to use the framework of empirical risk minimization that we\n",
    "talked about last time, so finding parameters that minimize\n",
    "some loss o the training set. Where classification differs\n",
    "quite a bit from regression is on how we want to measure\n",
    "misclassifications."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Picking a loss?\n",
    "\n",
    "$$\\hat{y} = \\text{sign}(w^T \\textbf{x} + b)$$\n",
    "\n",
    "$$\\min_{w \\in ℝ^{p}, b \\in \\mathbb{R}} \\sum_{i=1}^n 1_{y_i \\neq \\text{sign}(w^T \\textbf{x} + b)}$$\n",
    "\n",
    ".center[\n",
    "![:scale 40%](images/binary_loss.png)\n",
    "]\n",
    "\n",
    "\n",
    "\n",
    "So we need to define a loss function for given w and b that\n",
    "tell us how well they fit the training set. Obvious Idea:\n",
    "Minimize number of misclassifications aka 0-1 loss but this\n",
    "loss is non-convex, not continuous and minimizing it is\n",
    "NP-hard. So we need to relax it, which basically means we\n",
    "want to find a convex upper bound for this loss. This is not\n",
    "done on the actual prediction, but on the inner product $w^T\n",
    "x$, which is also called the decision function. So this\n",
    "graph here has the inner product on the x axis, and shows\n",
    "what the loss would be for class 1. The 0-1 loss is zero if\n",
    "the decision function is positive, and one if it's negative.\n",
    "Because a positive decision function means a positive\n",
    "predition, means correct classification in the case of y=1.\n",
    "A negative prediction means a wrong classification, which is\n",
    "penalized by the 0-1 loss with a loss of 1, i.e. one\n",
    "mistake.\n",
    "\n",
    "The other losses we'll talk about are mostly the hinge loss\n",
    "and the log loss. You can see they are both upper bounds on\n",
    "the 0-1 loss but they are convex and continuous. Both of\n",
    "these losses care not only that you make a correct\n",
    "prediction, but also \"how correct\" your prediction is, i.e.\n",
    "how positive or negative your decision function is. We'll\n",
    "talk a bit more about the motivation of these two losses,\n",
    "starting with the logistic loss."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Logistic Regression\n",
    "\n",
    "\n",
    ".left-column[\n",
    "$$\\log\\left(\\frac{p(y=1|x)}{p(y=-1|x)}\\right) = w^T\\textbf{x} + b$$\n",
    "\n",
    "$$p(y=1|\\textbf{x}) = \\frac{1}{1+e^{-w^T\\textbf{x} -b }}$$\n",
    "\n",
    "$$\\min_{w \\in ℝ^{p}, b \\in \\mathbb{R}} \\sum_{i=1}^n \\log(\\exp(-y_i(w^T \\textbf{x}_i + b)) + 1)$$\n",
    "\n",
    "\n",
    "$$\\hat{y} = \\text{sign}(w^T\\textbf{x} + b)$$\n",
    "]\n",
    ".right-column[\n",
    "![:scale 90%](images/logit.png)]\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "Logistic regression is probably the most commonly used\n",
    "linear classifier, maybe the most commonly used classifier\n",
    "overall. The idea is to model the log-odds, which is log\n",
    "p(y=1|x) - log p(y=0|x) as a linear function, as shown here.\n",
    "Rearranging the formula, you get a model of p(y=1|x) as 1\n",
    "over 1 + ... This function is called the logistic sigmoid,\n",
    "and is drawn to the right here. Basically it squashed the\n",
    "linear function $w^Tx$ between 0 and 1, so that it can model\n",
    "a probability.\n",
    "\n",
    "Given this equation for p(y|x), what we want to do is\n",
    "maximize the probability of the training set under this\n",
    "model. This approach is known as maximum likelihood.\n",
    "Basically you want to find w and b such that they assign\n",
    "maximum probability to the labels observed in the training\n",
    "data. You can rearrange that a bit and end up with this\n",
    "equation here, which contains the log-loss as seen on the\n",
    "last slide.\n",
    "\n",
    "The prediction is the class with the higher probability. In\n",
    "the binary case, that's the same as asking whether the\n",
    "probability of class 1 is bigger or smaller than .5. And as\n",
    "you can see from the plot of the logistic sigmoid, the\n",
    "probability of the class +1 is greater than .5 exactly if\n",
    "the decision function $w^T x$ is greater than 0. So\n",
    "predicting the class with maximum probability is the same as\n",
    "predicting which side of the hyperplane given by w we are\n",
    "on.\n",
    "\n",
    "Ok so this is logistic regression. We minimize this loss and\n",
    "get a w which defines a hyper plane. But if you think back\n",
    "to last time, this is only part of what we want. This\n",
    "formulation tries to fit the training data, but it doesn't\n",
    "care about finding a simple solution."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Penalized Logistic Regression\n",
    "\n",
    "$$\\min_{w \\in ℝ^{p}, b \\in \\mathbb{R}}C \\sum_{i=1}^n\\log(\\exp(-y_i(w^T \\textbf{x}_i + b )) + 1) + ||w||_2^2$$\n",
    "\n",
    "$$\\min_{w \\in ℝ^{p}, b \\in \\mathbb{R}}C \\sum_{i=1}^n\\log(\\exp(-y_i (w^T \\textbf{x}_i + b)) + 1) + ||w||_1$$\n",
    "\n",
    "- C is inverse to alpha (or alpha / n_samples)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "- Both versions strongly convex, l2 version smooth (differentiable).\n",
    "\n",
    "- All points contribute to $w$ (dense solution to dual).\n",
    "\n",
    "So we can do the same we did for regression: we can add\n",
    "regularization terms using the L1 and L2 norm. The effects\n",
    "are the same as for regression: both push the coefficients\n",
    "towards zero, but the l1 norm encourages coefficients to be\n",
    "exactly zero, for the same reasons we discussed last time.\n",
    "\n",
    "You could also use a mixed penalty to get something like the\n",
    "elasticnet. That's not implemented in the logisticregression\n",
    "class in scikit-learn right now, but it's certainly a\n",
    "sensible thing to do.\n",
    "\n",
    "Here I used a slightly different notation as last time,\n",
    "though. I'm not using alpha to multiply the regularizer,\n",
    "instead I'm using C to multiply the loss. That's mostly\n",
    "because that's how it's done in scikit-learn and it has only\n",
    "historic reasons. The idea is exactly the same, only now C\n",
    "is 1 over alpha. So large C means heavy weight to the loss,\n",
    "means little regularization, while small C means less weight\n",
    "on the loss, means strong regularization.\n",
    "\n",
    "Depending on the model, there might be a factor of n_samples\n",
    "in there somewhere. Usually we try to make the objective as\n",
    "independent of the number of samples as possible in\n",
    "scikit-learn, but that might lead to surprises if you're not\n",
    "aware of it.\n",
    "\n",
    "Some side-notes on the optimization problem: here, as in\n",
    "regression, having more regularization makes the\n",
    "optimization problem easier. You might have seen this in\n",
    "your homework already, if you decrease C, meaning you add\n",
    "more regularization, your model fits more quickly.\n",
    "\n",
    "One particular property of the logistic loss, compared to\n",
    "the hinge loss we'll discuss next is that each data point\n",
    "contributes to the loss, so each data point has an effect on\n",
    "the solution. That's also true for all the regression models\n",
    "we saw last time."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Effect of regularization\n",
    "\n",
    "\n",
    ".center[\n",
    "![:scale 90%](images/logreg_regularization.png)\n",
    "]\n",
    "\n",
    "- Small C (a lot of regularization) limits the influence of individual points!\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "So I spared you with coefficient plots, because they looks\n",
    "the same as for regression. All the things I said about\n",
    "model complexity and dependency on the number of features\n",
    "and samples is as true for classification as it is for\n",
    "regression.\n",
    "\n",
    "There is another interesting way to thing about\n",
    "regularization that I found helpful, though. I'm not going\n",
    "to walk through the math for this, but you can reformulate\n",
    "the optimization problem and find that what the C parameter\n",
    "does is actually limit the influence of individual data\n",
    "points. With very large C, we said we have no\n",
    "regularization. It also means individual data points can\n",
    "have basically unlimited influence, as you can see here.\n",
    "There are two outliers here, which basically completely tilt\n",
    "the decision boundary. But if we decrease C, and therefore\n",
    "increase the regularization, what happens is that the\n",
    "influence of these outlier points becomes limited, and the\n",
    "other points get more influence."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#Max-Margin and Support Vectors\n",
    "\n",
    ".center[\n",
    "![:scale 75%](images/max_margin.png)\n",
    "]\n",
    "\n",
    "\n",
    "\n",
    "A point is within the margin if 〖y_i w〗^T x is smaller\n",
    "than one. That means if you have a smaller w, you basically\n",
    "have a smaller margin given that you're on the correct side.\n",
    "If you're on the wrong side, you'll have always have a loss.\n",
    "If you're in the correct side, if you're w^x is small, then\n",
    "you also have a loss."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    
    "\n",
    "#Max-Margin and Support Vectors\n",
    "$$ \\min_{w \\in \\mathbb{R}^p, b \\in \\mathbb{R}} C \\sum_{i=1}^n \\max(0, 1 - y_i (w^T\\mathbf{x} + b)) + ||w||^2_2 $$\n",
    "\n",
    "$$\\text{Within margin} \\Leftrightarrow y_i(w^T x  + b)\n",
    "<\n",
    " 1$$\n",
    "\n",
    "Smaller $w \\Rightarrow$ larger margin"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    
    "\n",
    "#Max-Margin and Support Vectors\n",
    "\n",
    ".left-column[\n",
    "![:scale 80%](images/max_margin_C_0.1.png)\n",
    "]\n",
    ".right-column[\n",
    "![:scale 80%](images/max_margin_C_1.png)\n",
    "]\n",
    "\n",
    "\n",
    "\n",
    "Here are two examples on the same dataset. Where I learned\n",
    "linear support vector machine with c-0.1, and c=1. With\n",
    "c=0.1, you have a wider margin. There are points inside the\n",
    "margin and all the points inside the margin are support\n",
    "vectors which contribute to the solution. Points that are\n",
    "outside of the margin and on the correct side doesn't\n",
    "contribute to the solution. These points are sort of\n",
    "classified correctly, not when they’re ignored. The normal\n",
    "vector is w and basically, the size of the margin is the\n",
    "inverse of the length of w. C=0.1 means I have less emphasis\n",
    "on the data fitting and more emphasis on the shrinking w.\n",
    "This will lead to a smaller w. If I have larger C that means\n",
    "less regularization, which will lead to a larger W, larger W\n",
    "means a smaller margin. So there are fewer points here, they\n",
    "are inside the margin and therefore, fewer support vectors.\n",
    "More regularization usually means a larger margin but more\n",
    "points inside the margin. Also, more support vectors mean\n",
    "there are more data points that actually influence the\n",
    "solution."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## (soft margin) linear SVM\n",
    "\n",
    ".larger[\n",
    "$$\\min_{w \\in ℝ^{p}, b \\in \\mathbb{R}}C \\sum_{i=1}^n\\max(0,1-y_i(w^T \\textbf{x}_i + b)) + ||w||_2^2$$\n",
    "\n",
    "$$\\min_{w \\in ℝ^{p}, b \\in \\mathbb{R}}C \\sum_{i=1}^n\\max(0,1-y_i(w^T \\textbf{x}_i + b))+ ||w||_1$$\n",
    "]\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "- Both versions strongly convex, neither smooth.\n",
    "\n",
    "- Only some points contribute (the support vectors) to $w$ (sparse solution to dual).\n",
    "\n",
    "Moving from logistic regression to linear SVMs is just a\n",
    "matter of changing the loss from the log loss to the hinge\n",
    "loss. The hinge-loss is defined as ... And we can penalize\n",
    "using either l1 or l2 norm, or again, in principle also\n",
    "elastic net. This formulation with the hinge loss doesn't\n",
    "really make sense without the penalty, because of the\n",
    "formulation of the hinge loss. What this loss says is\n",
    "basically \"if you predict the right class with a margin of\n",
    "1, there is no loss\". Otherwise the loss is linear in the\n",
    "decision function. So you need to be on the right side of\n",
    "the hyperplane by a given amount, and then there is no more\n",
    "loss. That's the reason you need the penalty, for the 1 to\n",
    "make sense. Otherwise you could just scale up $w$ to make it\n",
    "far enough on the right side. But the regularization\n",
    "penalizes growing $w$.\n",
    "\n",
    "The hinge loss has a kink, same as the l1 norm, and so it's\n",
    "not a smooth optimization problem any more, but that's not\n",
    "really a big deal. What's interesting is that all the points\n",
    "that are classified correctly with a margin of at least 1\n",
    "have a loss of zero, and so they don't influence the\n",
    "solution any more. All the point that are not classified\n",
    "correctly by this margin are the ones that do influence the\n",
    "solution and they are called the support vectors.\n",
    "\n",
    "FIXME graph of not influencing the solution?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    
    "## Logistic Regression vs SVM\n",
    ".compact[\n",
    "$$\\min_{w \\in ℝ^{p}, b \\in \\mathbb{R}}C \\sum_{i=1}^n\\log(\\exp(-y_i(w^T \\textbf{x}_i+b)) + 1) + ||w||_2^2$$\n",
    "$$\\min_{w \\in ℝ^{p}, b \\in \\mathbb{R}}C \\sum_{i=1}^n\\max(0,1-y_i(w^T \\textbf{x}_i + b)) + ||w||_2^2$$\n",
    "\n",
    "![:scale 35%](images/binary_loss.png)\n",
    "]\n",
    "\n",
    "\n",
    "\n",
    "So this is the main difference between logistic regression\n",
    "and linear SVMs: Does it penalize misclassifications\n",
    "according to the green line, or according to the blue line?\n",
    "In practice it doesn't make a big difference."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## SVM or LogReg?\n",
    "\n",
    ".center[\n",
    "![:scale 80%](images/svm_or_lr.png)\n",
    "]\n",
    "\n",
    "- Need compact model or believe solution is sparse? Use L1\n",
    "\n",
    "\n",
    "\n",
    "So which one of them should you use? If you need probability\n",
    "estimates, you should use logistic regression. If you don't,\n",
    "you can pick either, and it doesn't really matter. Logistic\n",
    "regression can be a bit faster to optimize in theory. If\n",
    "you're in a setting where there's many more feature than\n",
    "samples, it might make sense to use linear SVMs and solve\n",
    "the dual, but you can actually solve either of the problems\n",
    "in the dual, and we'll talk about what that means in\n",
    "practice in a little bit."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    
    "\n",
    "## Multiclass classification\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "Ok, so I think that's enough on the two loss functions and\n",
    "regularization, and hopefully you have a bit of a feel for\n",
    "how these two classifiers work, and also an understanding\n",
    "that they are in fact quite similar in practice.\n",
    "\n",
    "Next I want to look at how to go from binary classification\n",
    "to multi-class classification. Basically there is a simple\n",
    "but hacky way, and there's a slightly more complicated but\n",
    "theoretically sound way."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    
    "\n",
    "## Reduction to Binary Classification\n",
    ".padding-top[\n",
    ".left-column[\n",
    "### One vs Rest\n",
    "]\n",
    "\n",
    ".right-column[\n",
    "### One vs One\n",
    "]\n",
    "]\n",
    "\n",
    "\n",
    "The slightly hacky way is using what's known as a reduction.\n",
    "We're doing a reduction like in math: reducing one problem\n",
    "to another. In this case we're reducing the problem of\n",
    "multi-class classification into several instances of the\n",
    "binary classification problem. And we already know how to\n",
    "deal with binary classification.\n",
    "\n",
    "There are two straight-forward ways to reduce multi-class to\n",
    "binary classification. the first is called one vs rest, the\n",
    "second one is called one-vs-one."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    
    "\n",
    "## One Vs Rest\n",
    "\n",
    "For 4 classes:\n",
    "\n",
    "1v{2,3,4}, 2v{1,3,4}, 3v{1,2,4}, 4v{1,2,3}\n",
    "\n",
    "In general:\n",
    "\n",
    "n binary classifiers - each on all data\n",
    "\n",
    "\n",
    "\n",
    "FIXME terrible slide\n",
    "\n",
    "Let's start with One vs Rest. here, we learn one binary\n",
    "classifier for each class against the remaining classes. So\n",
    "let's say we have 4 classes, called 1 to 4.  First we learn\n",
    "a binary classifier of the points in class 1 vs the points\n",
    "in the classes 2, 3 and 4.  Then, we do the same for class\n",
    "2, and so on. The way we end up building as many classifiers\n",
    "as we have classes."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    
    "\n",
    "## Prediction with One Vs Rest\n",
    "\n",
    "\n",
    "\"Class with highest score\"\n",
    "\n",
    "$$\\hat{y} = \\text{arg}\\max_{i \\in Y} \\textbf{w}^T_i\\textbf{x} + b_i$$\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "To make a prediction, we compute the decision function of\n",
    "all classifiers, say 4 in the example, on a new data point.\n",
    "The one with the highest score for the positive class, the\n",
    "single class, wins, and that class is predicted.\n",
    "\n",
    "It's a little bit unclear why this works as well as it does.\n",
    "Maybe there's some papers about that now, but I'm not\n",
    "\n",
    "So in this case we have one coefficient vector w and one\n",
    "bias b for each class."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## One vs Rest Prediction\n",
    "\n",
    ".center[\n",
    "![:scale 80%](images/ovr_lines.png)\n",
    "]\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "Here is an illustration of what that looks like.\n",
    "Unfortunately it's a bit hard to draw 4 classes in general\n",
    "position in 2 dimensions, so I only used 3 classes here. So\n",
    "each class has an associated coefficient vector and bias,\n",
    "corresponding to a line. The line tries to separate this\n",
    "class from the other two classes.\n",
    "## Fixme draw ws?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## One vs Rest Prediction\n",
    "\n",
    ".center[\n",
    "![:scale 80%](images/ovr_boundaries.png)\n",
    "]\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "Here are the decision boundaries resulting from the these\n",
    "three binary classifiers. Basically what they say is that\n",
    "the line that is closest decides the class. What you can not\n",
    "see here is that each of the lines also have a magnitude\n",
    "associated with them. It's not only the direction of the\n",
    "normal vector that matters, but also the length. You can\n",
    "think of that as some form of uncertainty attached to the\n",
    "line."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [

    "\n",
    "## One Vs One\n",
    "\n",
    "- 1v2, 1v3, 1v4, 2v3, 2v4, 3v4\n",
    "- n * (n-1) / 2 binary classifiers - each on a fraction of the data\n",
    "\n",
    "\n",
    "- \"Vote for highest positives\"\n",
    "- Classify by all classifiers.\n",
    "- Count how often each class was predicted.\n",
    "- Return most commonly predicted class.\n",
    "- Again - just a heuristic.\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "FIXME terrible slide\n",
    "\n",
    "The other method of reduction is called one vs one. In one\n",
    "vs one, we build one binary model for each pair of classes.\n",
    "In the example of having four classes that is one for 1 vs\n",
    "2, one for 1v3 and so on. So we end up with n * (n - 1) /2\n",
    "binary classifiers. And each is trained only on the subset\n",
    "of the data that belongs to these classes.\n",
    "\n",
    "To make a prediction, we again apply all of the classifiers.\n",
    "For each class we count how often one of the classifiers\n",
    "predicted that class, and we predict the class with the most\n",
    "votes.\n",
    "\n",
    "Again, this is just a heuristic and there's not really a\n",
    "good theoretical explanation why this should work."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    
    "\n",
    "## One vs One Prediction\n",
    "\n",
    "![:scale 80%](images/ovo_lines.png)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "Here is an example for predicting on three classes in 2d\n",
    "using the one-vs-one heuristic. In the case of three\n",
    "classes, there's also three pairs. Three is a bit of a\n",
    "special case, with any more classes there would be more\n",
    "classifiers than classes.\n",
    "\n",
    "The dashed lines are colored according to the pair of\n",
    "classes they separate. So the green and blue line separates\n",
    "the green and blue classes. The data points belonging to the\n",
    "grey class were not used in building this model at all."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    
    "## One vs One Prediction\n",
    "\n",
    "\n",
    "![:scale 80%](images/ovo_boundaries.png)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "Looking at the predictions made by the one vs one classifier\n",
    "the correspondence to the binary decision boundaries is a\n",
    "bit more clear than for the one vs rest heuristic, because\n",
    "it only takes the actual boundaries into account, not the\n",
    "length of the normal vectors. That makes it easier to\n",
    "visualize the geometry, but it's also a bit of a downside of\n",
    "the method because it means it discards any notion of\n",
    "uncertainty that was present in the binary classifiers. The\n",
    "decision boundary for each class is given by the two lines\n",
    "that this class is involved in. So the grey class is bounded\n",
    "by the green and grey line and the blue and grey line.\n",
    "\n",
    "There is a triangle in the center in which there is one vote\n",
    "for each of the classes.  In this implemenatation the tie is\n",
    "broken to just always predict the first class, which is the\n",
    "green one. That might not be the best tie breaking strategy,\n",
    "but this is a relatively rare case, in particular if there's\n",
    "more than three classes.\n",
    "\n",
    "OVR and OVO are general heuristics not restricted to linear\n",
    "models. They can be used whenever a binary model for\n",
    "classification needs to be extended to the multi-class case.\n",
    "For logistic regression, there is actually a natural\n",
    "extension of the formulation, and we don't have to resort to\n",
    "these hacks."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    
    ".left-column[\n",
    "### One vs Rest\n",
    "- n_classes classifiers\n",
    "- trained on imbalanced datasets of original size\n",
    "- Retains some uncertainty?\n",
    "![:scale 80%](images/ovr_boundaries.png)\n",
    "]\n",
    "\n",
    ".right-column[\n",
    "### One vs One\n",
    "- n_classes * (n_classes - 1)/2  classifiers\n",
    "- trained on balanced subsets\n",
    "- No uncertainty propagated\n",
    "![:scale 80%](images/ovo_boundaries.png)\n",
    "]\n",
    "\n",
    "\n",
    "If original problem was balanced, that is..."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Multinomial Logistic Regression\n",
    "\n",
    "Probabilistic multi-class model:\n",
    "\n",
    "$$p(y=i|x) = \\frac{e^{\\textbf{w}_i^T\\textbf{x} + b_i}}{\\sum_{j=1}^k e^{\\textbf{w}_j^T\\textbf{x} + b_j}}$$\n",
    "\n",
    "$$\\min_{w \\in ℝ^{pk}, b \\in \\mathbb{R}^k} -\\sum_{i=1}^n \\log(p(y=y_i|x_i, w, b))$$\n",
    "\n",
    "$$\\hat{y} = \\text{arg} \\max_{i=1,...,k} \\textbf{w}^T_i\\textbf{x} + b_i$$\n",
    "\n",
    "- Same prediction rule as OvR !\n",
    "\n",
    "\n",
    "\n",
    "The binary logistic regression case can be generalized to\n",
    "multinomial logistic regression, in which we model the\n",
    "probability that i is one of the classes using this formula,\n",
    "which is also known as softmax. The probability is\n",
    "proportional to e to the minus $w^t x$ which is the same as\n",
    "in the binary case. But now we need to normalize it so that\n",
    "the sum over all classes is one. So we just divide it by\n",
    "this sum."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [

    "\n",
    "## In sckit-learn\n",
    "\n",
    "- OvO: only SVC\n",
    "- OvR: default for all linear models except for logistic regression\n",
    "- `LogisticRegression(multi_class='auto')`\n",
    "- `clf.decision_function` = $w^Tx + b$\n",
    "- `logreg.predict_proba`\n",
    "- `SVC(probability=True)` not great\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "All the models in scikit-learn have multi-class built-in and\n",
    "most of them use One versus Rest. There's only one model\n",
    "that uses One versus One which is SVC. The Kernel SVM uses\n",
    "One versus One because of the authors of the SVM like that.\n",
    "For historical reasons, logistic regression also uses One\n",
    "versus Rest by default in scikit-learn. That's probably not\n",
    "a good idea, but we can’t really change the default easily.\n",
    "Usually, if you do multiclass you probably want to use\n",
    "multinomial logistic regression and so you set multinomial\n",
    "to true and then it does multinomial logistic regression.\n",
    "Question: Does that make it run faster? Answer: Its unlikely\n",
    "to make it run faster, but it makes it more theoretically\n",
    "sound and gives you better probabilities. The probabilities\n",
    "that come out of it, if you do OvR, are a complete hack in\n",
    "the multi-class case but in the binary case, it’s the same.\n",
    "Logistic regression also has a predict_prob method. This\n",
    "method gives the probability estimates, so you get a vector\n",
    "of length number of classes for each data point. You might\n",
    "be tempted to do SVC (probability) equal to true. That is\n",
    "something we're going to talk about in a couple of weeks.\n",
    "This is is running calibration. Basically, this does the One\n",
    "versus One SVM and then it builds a second model on top that\n",
    "tries to estimate probabilities using built-in\n",
    "cross-validation. This will take forever and the outcome\n",
    "will probably be not that great. Don't do this unless you're\n",
    "really sure this is what you want to do. If you want\n",
    "probabilities just use logistic regression. predict_proba\n",
    "gives you the probabilities. If you call predict_proba, it\n",
    "will give you an array that has number of samples times\n",
    "number of classes and these entries will sum to one. And the\n",
    "prediction is just the arg max of these. You can call\n",
    "predict which will give you arg max while predict_proba will\n",
    "give you the probabilities as given by the model."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Multi-Class in Practice\n",
    "\n",
    "\n",
    "OvR and multinomial LogReg produce one coef per class:\n",
    "\n",
    ".center[\n",
    "![:scale 80%](images/multiclass_coef.png)\n",
    "]\n",
    "\n",
    "SVC would produce the same shape, but with different semantics!\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "FIXME screenshots\n",
    "\n",
    "In practice, I'm using logistic regression on the iris\n",
    "dataset. We have 50 data points, 4 features, 3 classes, each\n",
    "class has 50 samples, and we’re trying to classify different\n",
    "kinds of irises. Here, I'm looking at logistic regression\n",
    "and linear SVM, I built the model. So the coefficient W is\n",
    "stored in coef on this score. Everything in scikit-learn\n",
    "that's estimated from the data ends with an underscore. If\n",
    "it doesn't, it wasn't learned from the data. So coef_ are\n",
    "the coefficient that is learned by the model. They’re for\n",
    "logistic regression and linear Support Vector Machine,\n",
    "they're the same shape, three classes times four features\n",
    "but they have different semantics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    
    "\n",
    "![:scale 80%](images/multiclass_array.png)\n",
    "\n",
    "![:scale 80%](images/multiclass_barchart.png)\n",
    "\n",
    "(after centering data, without intercept)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "FIXME screenshots\n",
    "\n",
    "Here I’ve interpreted them. You can see the four features,\n",
    "for each feature and for each class, you have a coefficient.\n",
    "If the sepal width is big, then the setosa classifier is\n",
    "happy. If the sepal with is small then versicolor will have\n",
    "a large response. If the petal width is big then virginica\n",
    "will have a large response. This is a bar plot after\n",
    "coefficient vector here. This tells you what the classifier\n",
    "has learned. This is maybe for a very simple problem this is\n",
    "little much to look at but it's still way less to look at\n",
    "for any other model. If you used a random forest or\n",
    "something like that, there would be no way to visualize\n",
    "what's happening."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    
    "\n",
    "\n",
    "## Computational Considerations\n",
    "#(for all linear models)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "Now I want to talk about more general things, how to make\n",
    "your homework run faster, also called Computational\n",
    "Considerations."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [

    "\n",
    "## Solver choices\n",
    "\n",
    "- Don’t use `SVC(kernel='linear')`, use `LinearSVC`\n",
    "- For `n_features >> n_samples`: Lars (or LassoLars) instead of Lasso.\n",
    "- For small n_samples (\n",
    "<\n",
    "10.000?), don’t worry.\n",
    "- `LinearSVC`, `LogisticRegression`: `dual=False` if `n_samples >> n_features`\n",
    "- `LogisticRegression(solver=\"sag\")` for `n_samples` large.\n",
    "- Stochastic Gradient Descent for `n_samples` really\n",
    "large\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "Some of the things here are specific to scikit-learn and\n",
    "some are not. Scikit-learn has SVC and the linear SVC, and\n",
    "they're both support vector machines. SVC uses One versus\n",
    "One while linear SVC uses one versus rest. SVC uses the\n",
    "hinged loss while linear SVC uses squared hinge loss. Linear\n",
    "SVC will provide faster results than SVC. If you want to do\n",
    "regression with a large number of features, you should\n",
    "probably use Lars or LassoLars, which allows you to do\n",
    "feature selection much more quickly than Lasso. Generally,\n",
    "if you have a few samples, don't worry, any model will find\n",
    "and everything will be sparse. If you have, let's say 10,000\n",
    "samples all linear models will be fast all the time.\n",
    "Otherwise, use this for regression. For classification, if\n",
    "the number of samples is much greater than the number of\n",
    "features use dual=false. Basically, solving a dual problem\n",
    "means solving something where there are as many variables as\n",
    "the number of samples, that's the default. Whereas solving\n",
    "the primal problem, so dual=false means solving something\n",
    "that's with the number of variables as the same number of\n",
    "features. If the number of features is big, dual should be\n",
    "true, and if the number of samples is big dual should be\n",
    "false. If you have really a whole lot of samples you can use\n",
    "a recent solver called sag. This works really for really\n",
    "large samples. So LogisticRegression(solver=”sag”) that can\n",
    "use L1 or L2 penalties or whatever you want. Then finally,\n",
    "if you have an extremely large amount of data you can use\n",
    "Stochastic Gradient Descent. It has the STD classifier, STD\n",
    "regressor, and hopefully, we'll have enough time to talk\n",
    "about these today. But generally often setting dual to false\n",
    "will help you a lot and setting the solver to something else\n",
    "might help you. All of these basically give you the same\n",
    "solution but only at different speeds. I want to talk about\n",
    "some tips for getting cross-validation. There are some\n",
    "built-in tools for doing quicker cross-validation for linear\n",
    "models."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Exercise\n",
    "Load and preprocess the adult data as before.\n",
    "include dummy encoding and scaling\n",
    "Learn a logistic regression model and visualize the coefficients.\n",
    "Then grid-search the regularization parameter C.\n",
    "Compare the coefficients of the best model with the coefficients of a model with more regularization."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "adult = pd.read_csv(\"data/adult.csv\", index_col=0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# %load solutions/adult_classification.py"
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
